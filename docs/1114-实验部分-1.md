基于 MoE Gating 的可证鲁棒水印工程方案
=========================

(严格对齐 "moe_paradigm_rigorous_proofs.pdf" 理论框架)
----------------------------------------------

### 引言

本方案旨在将附件文稿中的信息论推导（从定理2.1到定理5.5）转化为一个可执行、可标定、可验证的工程实现。方案的核心是利用混合专家（MoE）架构中 Gating 网络的选择机制作为水印的信号载体，实现水印信号（专家激活模式）与攻击（输入级释义）的解耦（**目标1**），从而获得对抗攻击的次线性衰减（**目标2**）这一关键鲁棒性优势。

本方案将严格遵循文稿中的 Neyman-Pearson/LLR 最优检测器（**目标3**）和基于 Chernoff 信息的性能量化，并提供一个完整的参数标定流程，特别是如何工程化“安全系数 $c$”（**目标4**），以实现精度与鲁棒性之间的可控权衡。

### 1. 威胁模型 (Threat Model)

严格遵循文稿 1.1 节的定义，我们的威胁模型设定如下：

1. **对手能力（Attack Space,** $\mathcal{A}$**）**：
   
   * 对手**仅能**在输入级施加攻击，即 $\mathcal{A}_{direct} = \mathcal{X}$（输入文本空间）。
   
   * 对手**无法**访问或修改模型参数（Gating 网络权重、专家权重等）。
   
   * 攻击手段主要是**释义（Paraphrasing）**，包括同义词替换、句法重排、风格迁移等。

2. **信号–攻击解耦（Signal–Attack Decoupling）**：
   
   * **水印信号空间（**$\mathcal{S}$**）**：选择为 MoE 的**专家激活模式（Expert Activation Pattern）**，即 $\mathcal{S}_B = \{0,1\}^K$（**目标1**）。
   
   * **解耦性（Definition 1.2）**：在此威胁模型下，$\mathcal{S}_B \cap \mathcal{A}_{direct} = \emptyset$。对手无法直接修改激活模式 $S$，只能通过修改输入 $x \to x'$，间接影响 Gating 网络的输出 $g(x')$，从而间接影响 $S$。

3. **攻击强度量化（**$\gamma$**）**：
   
   * 如文稿定义 1.3，攻击强度 $\gamma$ 通过输入分布的 KL 散度（Kullback-Leibler Divergence）度量：

     $$
     \gamma = D_{KL}(D(X') || D(X))
     $$

* $\gamma$ 是后续所有鲁棒性分析（特别是 $O(\sqrt{\gamma})$）的核心自变量。

### 2. 水印嵌入机制 (Embedding Mechanism)

水印嵌入机制的目标是，在保持模型原始性能（如 PPL）影响最小的前提下，修改 Gating 网络的专家选择概率分布，使其从 $p_0$ 变为 $p_1$，且 $D_{KL}(p_1 || p_0) = \epsilon$。

1. **信号载体**：Gating 网络在每个 Token 位置生成的专家激活模式 $S_i$。

2. **嵌入点（Injection Point）**：在 MoE 层的 Gating 网络中，计算出原始 logits $l_0(x)$ 之后，`softmax` 和 `top-k` 操作之前。

3. **偏置生成（**$\Delta\ell$**）**：
   
   * **密钥（**$K_{sec}$**）**：一个秘密密钥，用于初始化伪随机数生成器（PRNG）。
   
   * **上下文（Context）**：使用当前 Token 的前 $n$ 个 Token（或其 embedding 的哈希）作为 PRNG 的种子（seed）。
   
   * **偏置向量**：PRNG $\text{PRNG}(K_{sec}, \text{Context})$ 生成一个偏置向量 $\Delta\ell(x) \in \mathbb{R}^K$。
   
   * 设计关键：$\Delta\ell$ 的设计必须是可控的，以精确匹配目标水印强度 $\epsilon$。根据文稿定理 3.3（式 25）：
     $$\epsilon = D_{KL}(p_1 || p_0) \approx \text{Var}_{e \sim p_0}[\Delta\ell(e)]$$
   
   * **实现**：我们可以设计 $\Delta\ell$ 为一个零均值向量，其中特定索引（例如，由 PRNG 选定的“绿色专家”）被赋予一个正偏置 $+b$，而其他专家被赋予一个负偏置 $-b'$（以保持均值为0），使得 $\text{Var}[\Delta\ell] \approx \epsilon$。

4. 水印 Gating Logits：

$$
l_1(x) = l_0(x) + \Delta\ell(x)
$$

5. 水印激活分布（$p_1$）：

   $ p_1(S|x) = \text{Top-k}(\text{softmax}(l_1(x)))$ 
   （$p_0$ 则使用 $l_0(x)$ 计算）。

### 3. 水印检测器 (Detector)

检测器严格采用文稿第 3.1 节中定义的最优 Neyman-Pearson 检验器。

1. **假设检验**：
   
   * $H_0$**（零假设）**：文本由无水印模型生成。观测到的激活序列 $S_1, ..., S_n$ 独立同分布于 $p_0$。
   
   * $H_1$**（备择假设）**：文本由含水印模型生成。观测到的激活序列 $S_1, ..., S_n$ 独立同分布于 $p_1$。

2. **最优检测统计量（LLR）**：
   
   * 根据定理 3.1，最优检测器是对数似然比（Log-Likelihood Ratio, LLR）：
     
     
     $$
     \Lambda_n = \sum_{i=1}^{n} \log \frac{p_1(S_i)}{p_0(S_i)}
     $$
   
   * 其中 $n$ 是待检测文本的 Token 长度。$p_1(S_i)$ 和 $p_0(S_i)$ 是在给定上下文 $x_i$ 时，观测到激活模式 $S_i$ 的（Top-k softmax）概率。

3. **判决规则**：
   
   * 给定一个显著性水平 $\alpha$（例如 $\alpha = 10^{-6}$），我们设定一个阈值 $\tau_\alpha$。
   
   * 如果 $\Lambda_n > \tau_\alpha$，则判为 $H_1$（有水印）。
   
   * 如果 $\Lambda_n \le \tau_\alpha$，则判为 $H_0$（无水印）。

4. **性能量化（Chernoff 信息）**：
   
   * 如定理 3.2，检测器的错误率（Type I & II error）由 Chernoff 信息 $D^*(p_0, p_1)$ 决定。
   
   * $D^*$ 是我们衡量水印“可区分度”的核心指标，也是 $O(\sqrt{\gamma})$ 衰减的主体（**目标3**）。

### 4. 核心：参数与常数标定 (Calibration)

这是将理论（定理 4.7, 5.2）落地为工程实践的最关键一步。我们的目标是标定出鲁棒性下界公式中的常数 $C$，并据此选择最优的安全系数 $c$。

核心公式 (Theorem 5.2):



$$
D_{adv}^* \ge D^*(0) - C \sqrt{\gamma \cdot D^*(0)} = \gamma c(c - C)
$$

其中 $\epsilon = D^*(0) = c^2\gamma$ (Definition 5.1)。

#### 步骤 4.1: 标定设计攻击强度 $\gamma_{design}$ (Target Attack Strength)

* **目的**：确定我们系统需要防御的“威胁等级”。

* **方法**（对标文稿 6.2 节 / 表 A1）：
  
  1. 取一个验证数据集（如 WikiText-103）。
  
  2. 使用一系列代表性的释义攻击模型（如 T5-paraphrase, GPT-3.5-paraphrase）。
  
  3. 测量攻击后文本分布 $D(X')$ 与原始分布 $D(X)$ 之间的 $D_{KL}$。
  
  4. （可选）遵循文稿 7.4 节的方法，建立编辑距离 $L$ 与 $\gamma$ 之间的上界关系。

* **工程决策**：根据测量结果，设定一个设计目标，例如 $\gamma_{design} = 0.03$ nats（对应中等强度的释义攻击）。

#### 步骤 4.2: 标定系统常数 $C$ (System Constant)

* **目的**：测量模型的“固有鲁棒性”。$C = C_{stability} \cdot C_{prop}$。

* **方法**（严格遵循文稿 7.1 和 7.2 节 / Algorithm 1 & 2）：
  
  1. **标定** $L_g$ **(Lipschitz Constant)**：
     
     * 遵循 **Algorithm 1**（文稿 7.1 节）。
     
     * 在 Embedding 空间对输入 $e$ 添加高斯噪声 $e' = e + \epsilon \cdot \mathcal{N}(0, I)$。
     
     * 测量 Gating logits 的变化 $\Delta l = ||l(e) - l(e')||_2$ 和输入的 L2 变化 $\Delta x = ||e - e'||_2$。
     
     * 计算 $r_i = \Delta l_i / \Delta x_i$ 的分布。
     
     * **取** $L_g = L_g^{0.95}$（95% 分位数），以避免极端值（排名交叉）的干扰，获得稳健估计（如文稿 6.5 节 / 表 D1）。
  
  2. **标定** $C_{prop}$ **(Propagation Constant)**：
     
     * 遵循 **Algorithm 2**（文稿 7.2 节）。
     
     * 对验证集样本 $(x_i, x_i')$ 计算其实际的 $\gamma_i = D_{KL}(D(x_i')||D(x_i))$。
     
     * 计算激活概率分布的总变差距离 $\delta_i = ||p(e|x_i') - p(e|x_i)||_{TV}$。
     
     * 使用稳健回归拟合 $C_{prop}$：$\delta_i \approx C_{prop} \cdot \sqrt{\gamma_i}$。
  
  3. **标定** $C_{stability}$ **(Stability Constant)**：
     
     * 遵循 **Algorithm 2** 后半部分。
     
     * 拟合 Chernoff 信息的变化：$|D^{*'} - D^*| \approx C_{stability}(\delta_p + \delta_q)\sqrt{D^*}$。
  
  4. **计算** $C$：
     
     * $C = C_{stability} \cdot C_{prop}$。这个值（例如 $C \approx 1.5$）是系统的“鲁棒性临界点”。

#### 步骤 4.3: 标定安全系数 $c^*$ (Optimal Security Factor)

* **目的**：在“鲁棒性”和“模型性能”之间找到最优平衡点（**目标4**）。

* **方法**（严格遵循文稿 5.2, 7.3 节 / Algorithm 3）：
  
  1. **约束**：必须选择 $c > C$ 才能保证鲁棒性（$D_{adv}^* > 0$）。
  
  2. 优化问题 (Theorem 5.5)：
     
     $$
     c^* = \arg\min_c [n^*(\gamma, c) + \lambda \Delta A(c)]
     $$
  
  3. **标定** $\Delta A(c)$**（性能成本函数）**：
     
     * 如 **Algorithm 3** 步骤 1。
     
     * 扫描一系列 $c$ 值（例如 $c \in [C, 2.5C]$）。
     
     * 对每个 $c$，嵌入对应强度 $\epsilon = c^2 \gamma_{design}$ 的水印。
     
     * 在验证集上测量 PPL 或下游任务精度的下降 $\Delta A(c)$。
     
     * 拟合多项式 $\Delta A(c) = a \cdot c^p + b \cdot c^q$。
  
  4. **标定** $n^*(\gamma, c)$**（样本复杂度）**：
     
     * 使用理论公式：$n^*(\gamma, c) = \frac{\log(1/\delta)}{\gamma_{design} c(c - C)}$。
     
     * $\delta$ 是目标 Type II 错误率（例如 $\delta = 1 - 0.999 = 0.001$）。
  
  5. **求解** $c^*$：
     
     * 选择一个 $\lambda$（例如 $\lambda=1$ 代表平衡，$\lambda=100$ 代表强安全）。
     
     * 通过网格搜索（如 **Algorithm 3** 步骤 2）找到最小化目标函数 $f(c) = n^*(c) + \lambda \Delta A(c)$ 的 $c^*$。

#### 步骤 4.4: 部署参数

1. **安全密钥** $K_{sec}$：部署时设定。

2. 水印强度 $\epsilon$：由标定结果 $c^*$ 和 $\gamma_{design}$ 共同确定：
   
   $$
   \epsilon_{deploy} = (c^*)^2 \cdot \gamma_{design}
   $$

3. **嵌入机制（**$\Delta\ell$**）**：在工程上（步骤 2）调整偏置 $b$，使得 $\text{Var}[\Delta\ell] \approx \epsilon_{deploy}$。

4. **检测阈值** $\tau_\alpha$：通过在 $H_0$ 数据集上运行 LLR 检测器 $\Lambda_n$ 获得统计分布，设定 $\alpha$ 分位数（例如 $\alpha = 10^{-6}$）为 $\tau_\alpha$。

### 5. 工程实现与实验评估 (Implementation & Evaluation)

#### 5.1 工程实现 (伪代码)

    # 假设 GatingNetwork 是 MoE 层的 Gating 模块
    # K_sec 和 context_hash 已定义
    
    class WatermarkedGatingNetwork(GatingNetwork):
    
        def __init__(self, K_sec, epsilon_deploy, C_calibrated):
            super().__init__()
            self.K_sec = K_sec
            self.epsilon = epsilon_deploy
            # c = sqrt(epsilon / gamma_design)
            # assert c > C_calibrated, "Security factor c must be > C"
    
        def get_bias_vector(self, context_hash):
            # 严格遵循文稿 2. 节的嵌入机制
            # PRNG(K_sec, context_hash) -> delta_l
            # 确保 Var[delta_l] approx self.epsilon
            prng = PRNG(seed=hash(self.K_sec + context_hash))
            delta_l = prng.generate_zero_mean_bias(variance=self.epsilon) 
            return delta_l
    
        def forward(self, x):
            # x 是输入 token embedding
            context_hash = get_context_hash(x) # 假设
    
            # 1. 原始 logits
            l_0 = self.mlp(x) # [batch, seq_len, K_experts]
    
            # 2. 生成并注入偏置
            delta_l = self.get_bias_vector(context_hash)
            l_1 = l_0 + delta_l
    
            # 3. 计算 p0 (用于检测器) 和 p1 (用于路由)
            # 注意: p0 和 p1 都是完整的 softmax 分布, 
            # 而 S 是 top-k 的结果
            p_0_dist = softmax(l_0)
            p_1_dist = softmax(l_1)
    
            # 4. Gating 路由（实际执行）
            router_logits = p_1_dist 
            S_indices, S_scores = self.top_k(router_logits)
    
            # 5. 返回路由结果和检测器所需信息
            # p0, p1, S_indices 将被用于计算 LLR
            return S_indices, S_scores, (p_0_dist, p_1_dist, S_indices)



#### 5.2 实验评估（对标文稿第 6 节）

为验证本方案的有效性，必须执行以下实验：

1. **实验 A：基线线性衰减（对标 6.3 节）**
   
   * **目的**：复现 Token-Logit (KGW) 水印的 $O(\gamma)$ 线性衰减。
   
   * **设置**：在_同一_ MoE 模型上实现 KGW 水印。
   
   * **测量**：测量 Z-Score 随攻击强度 $\gamma$ 的变化。
   
   * **预期结果**：Z-Score 呈线性下降（如表 C1 范式 A），在 $\gamma \approx 0.03$ 时完全失效。

2. **实验 B：MoE 次线性衰减（对标 6.4 节 / 目标2）**
   
   * **目的**：**核心验证**。证明本方案的 $O(\sqrt{\gamma})$ 次线性衰减。
   
   * **设置**：使用本方案（MoE Gating 水印）。
   
   * **测量**：测量 $D_{adv}^*$（或 LLR 均值 $\mathbb{E}[\Lambda_n]/n$）随 $\gamma$ 的变化。
   
   * **预期结果**：$D^*$ 呈次线性下降（如表 C1 范式 B），拟合曲线 $\Delta D^* \propto \sqrt{\gamma}$。在 $\gamma = 0.03$ 时，信号保持 > 70% 强度。

3. **实验 C：参数标定验证（对标 6.5, 6.6 节）**
   
   * **目的**：验证步骤 4 中标定的 $L_g$ 和 $c^*$ 是否准确。
   
   * **测量** $L_g$：执行实验 6.5，验证 $L_g^{0.95}$ 与标定值一致（如表 D1）。
   
   * **测量** $c^*$：执行实验 6.6，验证 $c^*$ 的最优值（如表 E1），确认理论预测的 $n^*$ 和 $\Delta A$ 与实测值吻合。

### 6. 结论

本方案完整地将 `moe_paradigm_rigorous_proofs.pdf` 中的信息论框架工程化。通过锚定“信号–攻击解耦”的核心优势，采用 MoE 专家激活模式作为信号载体，我们构建了一个具有可证鲁棒性下界（$O(\sqrt{\gamma})$）的水印系统。

该系统优于传统 $O(\gamma)$ 方案，其鲁棒性与性能的权衡由“安全系数 $c$”精确控制，且 $c$ 值可通过本方案提供的标定流程（Algorithm 1-3）在工程上系统性地确定。
